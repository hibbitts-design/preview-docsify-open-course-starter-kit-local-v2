{"version":3,"file":"docsify-tabs.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n    tabsContainer  : 'content',\n    tabBlock       : 'docsify-tabs',\n    tabButton      : 'docsify-tabs__tab',\n    tabButtonActive: 'docsify-tabs__tab--active',\n    tabContent     : 'docsify-tabs__content'\n};\nconst regex = {\n    // Matches markdown code blocks (inline and multi-line)\n    // Example: ```text```\n    codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n    // Matches tab replacement comment\n    // 0: Match\n    // 1: Replacement HTML\n    commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*?) -->`),\n\n    // Matches inner-most tab set by start/end comment\n    // Ex: <!-- tabs:start --> (<!-- tabs:start --><!-- tabs:end -->) <!-- tabs:end -->\n    // 0: Match\n    // 1: Indent\n    // 2: Start comment: <!-- tabs:start -->\n    // 3: undefined\n    // 4: End comment: <!-- tabs:end -->\n    tabBlockMarkup: /( *)(<!-+\\s+tabs:\\s*?start\\s+-+>)(?:(?!(<!-+\\s+tabs:\\s*?(?:start|end)\\s+-+>))[\\s\\S])*(<!-+\\s+tabs:\\s*?end\\s+-+>)/,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: <!-- tab:Label -->\n    // 2: Content\n    tabCommentMarkup: /[\\r\\n]*(\\s*)<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]*\\s*(?=<!-+\\s+tabs?:(?!replace))/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: #### **Label** OR #### __Label__\n    // 2: Content\n    tabHeadingMarkup: /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n    persist    : true,\n    sync       : true,\n    theme      : 'classic',\n    tabComments: true,\n    tabHeadings: true\n};\n\nconst storageKeys = {\n    get persist() {\n        return `docsify-tabs.persist.${window.location.pathname}`;\n    },\n    sync: 'docsify-tabs.sync'\n};\n\n\n// Functions\n// =============================================================================\n/**\n * Traverses the element and its parents until it finds a node that matches the\n * provided selector string. Will return itself or the matching ancestor.\n *\n * @param {object} elm\n * @param {string} closestSelectorString\n * @return {(object|null)}\n */\nfunction getClosest(elm, closestSelectorString) {\n    if (Element.prototype.closest) {\n        return elm.closest(closestSelectorString);\n    }\n\n    while (elm) {\n        const isMatch = matchSelector(elm, closestSelectorString);\n\n        if (isMatch) {\n            return elm;\n        }\n\n        elm = elm.parentNode || null;\n    }\n\n    return elm;\n}\n\n/**\n * Checks to see if the element would be selected by the provided selectorString\n *\n * @param {object} elm\n * @param {string} selectorString\n * @return {boolean}\n */\nfunction matchSelector(elm, selectorString) {\n    const matches = Element.prototype.matches ||\n        Element.prototype.msMatchesSelector ||\n        Element.prototype.webkitMatchesSelector;\n\n    return matches.call(elm, selectorString);\n}\n\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content, vm) {\n    const codeBlockMatch   = content.match(regex.codeMarkup) || [];\n    const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n        const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n        // Replace code block with marker to ensure tab markup within code\n        // blocks is not processed. These markers are replaced with their\n        // associated code blocs after tabs have been processed.\n        content = content.replace(item, () => codeMarker);\n\n        return codeMarker;\n    });\n    const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n    const tempElm  = document.createElement('div');\n\n    let tabBlockMatch = content.match(regex.tabBlockMarkup);\n    let tabIndex = 1;\n\n    // Process each tab set\n    while (tabBlockMatch) {\n        let tabBlockOut = tabBlockMatch[0];\n\n        const tabBlockIndent = tabBlockMatch[1];\n        const tabBlockStart  = tabBlockMatch[2];\n        const tabBlockEnd    = tabBlockMatch[4];\n        const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlockOut);\n        const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlockOut);\n\n        let tabMatch;\n        let tabStartReplacement = '';\n        let tabEndReplacement   = '';\n\n        if (hasTabComments || hasTabHeadings) {\n            tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n            tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n            // Process each tab panel\n            while ((tabMatch = (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlockOut) : null) || (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlockOut) : null)) !== null) {\n                // Process tab title as markdown\n                // Ex: <!-- tab:**Bold** and <span style=\"color: red;\">red</span> -->\n                tempElm.innerHTML = tabMatch[2].trim() ? vm.compiler.compile(tabMatch[2]).replace(/<\\/?p>/g, '') : `Tab ${tabIndex}`;\n\n                const tabTitle = tempElm.innerHTML;\n                const tabContent = (tabMatch[3] || '').trim();\n                const tabData = (\n                    tempElm.textContent ||\n                    (tempElm.firstChild.getAttribute('alt') || tempElm.firstChild.getAttribute('src'))\n                ).trim().toLowerCase();\n\n                // Use replace function to avoid regex special replacement\n                // strings being processed ($$, $&, $`, $', $n)\n                tabBlockOut = tabBlockOut.replace(tabMatch[0], () => [\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabData}\">${tabTitle}</button> -->`,\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabData}\"> -->`,\n                    `\\n\\n${tabBlockIndent}${tabContent}`,\n                    `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`,\n                ].join(''));\n\n                tabIndex++;\n            }\n        }\n\n        tabBlockOut = tabBlockOut.replace(tabBlockStart, () => tabStartReplacement);\n        tabBlockOut = tabBlockOut.replace(tabBlockEnd, () => tabEndReplacement);\n        content = content.replace(tabBlockMatch[0], () => tabBlockOut);\n\n        tabBlockMatch = content.match(regex.tabBlockMarkup);\n    }\n\n    // Restore code blocks\n    codeBlockMarkers.forEach((item, i) => {\n        content = content.replace(item, () => codeBlockMatch[i]);\n    });\n\n    return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n    let tabReplaceMatch; // eslint-disable-line no-unused-vars\n\n    while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n        const tabComment     = tabReplaceMatch[0];\n        const tabReplacement = tabReplaceMatch[1] || '';\n\n        html = html.replace(tabComment, () => tabReplacement);\n    }\n\n    return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: the tab containing the\n * matching element ID from the URL, the first tab in the group, or the last tab\n * clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n    const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlocks         = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n    const tabStoragePersist = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n    const tabStorageSync    = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n    setActiveTabFromAnchor();\n\n    tabBlocks.forEach((tabBlock, index) => {\n        let activeButton = Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, `.${classNames.tabButtonActive}`))[0];\n\n        if (!activeButton) {\n            if (settings.sync && tabStorageSync.length) {\n                activeButton = tabStorageSync\n                    .map(label => Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${label}\"]`))[0])\n                    .filter(elm => elm)[0];\n            }\n\n            if (!activeButton && settings.persist) {\n                activeButton = tabBlock.querySelector(Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${tabStoragePersist[index]}\"]`))[0]);\n            }\n\n            activeButton = activeButton || tabBlock.querySelector(`.${classNames.tabButton}`);\n            activeButton && activeButton.classList.add(classNames.tabButtonActive);\n        }\n    });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm Tab toggle element to mark as active\n */\nfunction setActiveTab(elm, _isMatchingTabSync = false) {\n    const activeButton = getClosest(elm, `.${classNames.tabButton}`);\n\n    if (activeButton) {\n        const activeButtonLabel = activeButton.getAttribute('data-tab');\n        const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n        const tabBlock          = activeButton.parentNode;\n        const tabButtons        = Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, 'button'));\n        const tabBlockOffset    = tabBlock.offsetTop;\n\n        tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n        activeButton.classList.add(classNames.tabButtonActive);\n\n        if (!_isMatchingTabSync) {\n            if (settings.persist) {\n                const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n                const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n                const tabStorage    = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n\n                tabStorage[tabBlockIndex] = activeButtonLabel;\n                sessionStorage.setItem(storageKeys.persist, JSON.stringify(tabStorage));\n            }\n\n            if (settings.sync) {\n                const tabButtonMatches = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`)) : [];\n                const tabStorage       = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n                tabButtonMatches.forEach(tabButtonMatch => {\n                    setActiveTab(tabButtonMatch, true);\n                });\n\n                // Maintain position in viewport when tab group's offset changes\n                window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n\n                // Remove existing label if not first in array\n                if (tabStorage.indexOf(activeButtonLabel) > 0) {\n                    tabStorage.splice(tabStorage.indexOf(activeButtonLabel), 1);\n                }\n\n                // Add label if not already in first position\n                if (tabStorage.indexOf(activeButtonLabel) !== 0) {\n                    tabStorage.unshift(activeButtonLabel);\n                    sessionStorage.setItem(storageKeys.sync, JSON.stringify(tabStorage));\n                }\n            }\n        }\n    }\n}\n\n/**\n * Sets the active tab based on the anchor ID in the URL\n */\nfunction setActiveTabFromAnchor() {\n    const anchorID              = decodeURIComponent((window.location.hash.match(/(?:id=)([^&]+)/) || [])[1]);\n    const anchorSelector        = anchorID && `.${classNames.tabBlock} #${anchorID}`;\n    const isAnchorElmInTabBlock = anchorID && document.querySelector(anchorSelector);\n\n    if (isAnchorElmInTabBlock) {\n        const anchorElm = document.querySelector(`#${anchorID}`);\n\n        let tabContent;\n\n        if (anchorElm.closest) {\n            tabContent = anchorElm.closest(`.${classNames.tabContent}`);\n        }\n        else {\n            tabContent = anchorElm.parentNode;\n\n            while (tabContent !== document.body && !tabContent.classList.contains(`${classNames.tabContent}`)) {\n                tabContent = tabContent.parentNode;\n            }\n        }\n\n        setActiveTab(tabContent.previousElementSibling);\n    }\n}\n\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n    let hasTabs = false;\n\n    hook.beforeEach(function(content) {\n        hasTabs = regex.tabBlockMarkup.test(content);\n\n        if (hasTabs) {\n            content = renderTabsStage1(content, vm);\n        }\n\n        return content;\n    });\n\n    hook.afterEach(function(html, next) {\n        if (hasTabs) {\n            html = renderTabsStage2(html);\n        }\n\n        next(html);\n    });\n\n    hook.doneEach(function() {\n        if (hasTabs) {\n            setDefaultTabs();\n        }\n    });\n\n    hook.mounted(function() {\n        const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n        tabsContainer && tabsContainer.addEventListener('click', function handleTabClick(evt) {\n            setActiveTab(evt.target);\n        });\n\n        window.addEventListener('hashchange', setActiveTabFromAnchor, false);\n    });\n}\n\n\nif (window) {\n    window.$docsify = window.$docsify || {};\n\n    // Add config object\n    window.$docsify.tabs = window.$docsify.tabs || {};\n\n    // Update settings based on $docsify config\n    Object.keys(window.$docsify.tabs).forEach(key => {\n        if (Object.prototype.hasOwnProperty.call(settings, key)) {\n            settings[key] = window.$docsify.tabs[key];\n        }\n    });\n\n    // Add plugin data\n    window.$docsify.tabs.version = pkgVersion;\n\n    // Init plugin\n    if (settings.tabComments || settings.tabHeadings) {\n        window.$docsify.plugins = [].concat(\n            (window.$docsify.plugins || []),\n            docsifyTabs\n        );\n    }\n}\n"],"names":["css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","concat","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","storageKeys","window","location","pathname","getClosest","elm","closestSelectorString","Element","prototype","closest","matchSelector","parentNode","selectorString","matches","msMatchesSelector","webkitMatchesSelector","call","setActiveTab","_isMatchingTabSync","activeButton","activeButtonLabel","getAttribute","querySelector","tabButtons","Array","apply","children","filter","tabBlockOffset","offsetTop","forEach","buttonElm","classList","remove","add","tabBlocks","querySelectorAll","tabBlockIndex","indexOf","tabStorage","JSON","parse","sessionStorage","getItem","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","splice","unshift","setActiveTabFromAnchor","anchorID","decodeURIComponent","hash","match","anchorSelector","anchorElm","body","contains","previousElementSibling","$docsify","tabs","Object","keys","key","hasOwnProperty","version","plugins","hook","vm","hasTabs","beforeEach","content","test","codeBlockMatch","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","tempElm","tabBlockMatch","tabIndex","_loop","tabBlockOut","tabBlockIndent","tabBlockStart","tabBlockEnd","hasTabComments","hasTabHeadings","tabMatch","tabStartReplacement","tabEndReplacement","join","_loop2","innerHTML","trim","compiler","compile","tabTitle","tabData","textContent","toLowerCase","exec","renderTabsStage1","afterEach","html","next","tabReplaceMatch","_loop3","tabComment","tabReplacement","renderTabsStage2","doneEach","tabStoragePersist","tabStorageSync","index","length","label","mounted","addEventListener","evt","target"],"mappings":"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"}